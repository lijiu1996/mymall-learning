# sql原理问题

### 2. mysql的锁机制以及隔离级别问题

原子性 -- 预写undolog 保证能够回滚

持久性 -- 预写redolog 保证能够持久化

事务隔离性问题 脏写 脏读 不可重复读 幻读

事务的解决方案 锁机制(写写)/MVCC(写读)

MVCC的实现原理 创建createView 遍历undolog 找到第一个能访问到的数值

普通读走mvcc 不加任何锁

也可以使用加锁读 for update

一个非常需要掌握的问题就是sql语句具体会加哪些锁 是行锁还是表锁
比如sql for update 语句 和 普通update 语句 

成功使用索引 -- 行锁
全表扫描    -- rc情况下 是加行锁
          -- rr情况下 为防止幻读 会加间隙锁 所以看起来会锁表

### 3. 预防数据库死锁

死锁原因排查

预防 -- 1. 避免事务过长
       2. 合理设计索引 无索引情况下会多加上很多的锁
       3. 统一执行顺序 加锁顺序不一致往往会更容易造成死锁
       4. 热点key放到事务的最后面 减少锁持有时间

### 4. Spring事务

1. 介绍下什么是Spring事务传播行为 
正常情况下 mysql当你在一个事务中 再开启一个新事务时 会强制把当前事务提交 当然这肯定不符合我们原有的业务逻辑
针对此场景spring提供了三种支持 一是直接融入当前事务 而是将当前事务挂起开启新事务 三是嵌套事务机制
    挂起和嵌套事务有什么区别呢？ -- 挂起如果外面的回滚 里面的不会回滚
                           -- 嵌套的话如果外面事务回滚 里面的事务也会回滚(保存点机制)

2. 可以配置超时时间
可以配置只读事务(相比于只读事务进行了一些数据库上的优化)

3. @Transactional注解失效场景
非public方法

4. spring事务机制实现原理
三大抽象 TransactionManager TransactionDefinition、TransactionStatus
如何进行编程式事务控制

5. spring事务扩展点 
transactionSynchronization 事务执行成功以后触发

### 5. @Transactional 中开启异步调用 @Async 会发生什么

@Async切面的优先级最高 所以方法调用无论如何都会开启在新线程中
这样一来就跟@Transactional开启新事务的配置等同了(实际上还是有区别的 异步执行减少了阻塞时间)

多个线程之间异常是互相隔离的 比如你在一个线程内开启了事务 然后调用了一个异步方法
异步方法去开启了新线程执行 异步方法执行出现了异常 自己回滚了 但是主线程的方法并不会回滚

进阶拓展1:
@Async注解如何实现回调逻辑呢
方法返回Future future虽然可以传递异步的结果,但是Future本身并不提供回调的功能 但是需要线程循环去判断 十分的不优雅
最好使用jdk或者guava提供的ListenableFuture 注册一个回调函数

进阶拓展2: 如何保证多线程情况下事务执行的一致性呢？
编程式事务 + 然后用全局变量判断是否产生过异常

总结 异步调用适用在没有依赖的两个场景 比如订单和短信业务
这里需要注意一个问题 由于线程一的事务没有提交 所以线程一的历史修改线程二是看不到的

### 6. !!!加锁和事务 系统设计场景题

锁和事务的关系区分
    1.首先要明确锁和事务是两个概念, 事务主要是保证sql执行的原子性 即一个事务之间要么全部成功要么做回滚 锁则是避免多个事务执行相互影响
    2.有人说事务的隔离性可以保证 但是实际上事务的隔离性其实并不足以保证多线程环境下的一致性 大多数场景下还是需要再业务代码中手动加锁
    比如两个事务之间需要严格有序执行的场景 如果不加锁 第一个事务没有提交 第二个事务看不到第一个事务的修改 就会导致执行错误的逻辑
    事务的隔离性在我看来适用于两个事务之间相互不需要可见或者说可见性比较低的场景 如果对于可见性有较高的要求 就要手动引入锁来进行串行化处理
    3.这个加锁还有一个讲究 就是锁要加在事务提交的外面 否则会失去效果

如果在事务中进行加锁解锁 和在事务外进行加锁解锁有什么区别

答 事务内部进行加锁解锁起不到应有的效果 锁的目的是防止事务重复执行
但是事务可能还没有提交 就把锁释放了 此时若恰好另一个事务进来 由于这行代码没有提交 实际上加锁的意义又没了

解决方案 锁放在事务外面 + 唯一索引兜底

