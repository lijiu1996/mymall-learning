# 分布式事务学习

### 本地事务与rpc请求一致性的解决方案 -- 本地消息表

核心思考点 保证的是两个系统内的数据处理 要么全部成功 要么全部失败 

rpc调用在事务中
    存在问题是 本地事务回滚 rpc调用成功
    此时可能会产生难以重试的问题 因为本地已经回滚掉了 没有保存原始数据

rpc调用不在事务中
    本地事务处理成功(同步维护一个本地消息表) 再定时任务进行rpc调用
    如果rpc调用失败 则可以根据本地消息表的结果进行重试 此时由于本地事务保存了原始数据 所以支持回滚

如何处理下游系统不支持的情况 比如库存不够 此时无论如何重试 都无法实现业务需求
向消息队列中写入失败信息 发回给原有服务 删除本地消息表停止重试

极海对本地消息表方案进行的扩展
1. 原始方案没有一致性问题 但存在及时性问题 因为定时任务去发起远程调用会有延迟
2. 可以根据任务场景进行进一步优化 就是写本地消息表后马上实时进行远程调用
又分成两种 先写本地消息表 远程调用成功后删掉
         以及先远程调用 失败后写本地消息表
           (在远程调用失败之后在开启事务)
前面的方案 事务过长
后面的方案 存在宕机导致本地消息表未写入 消息丢失的极端情况
此时根据业务场景进行抉择 如果消息不是很重要 丢了就丢了 选后面那种

### 应用如何实现接口幂等性

根据具体业务情况而定 如果是set 无所谓
如果是插入 主键
如果是side effect 检查id

实现一 数据库唯一性约束
实现二 额外的状态字段进行数据库逻辑判断
实现三 redis防重 

考虑一个问题啊 就是第一个请求还没有执行成功 数据库尚未建立
此时第二个请求进来了 又会去数据库执行操作 这样是否对db负载过大

幂等设计该如何减轻mysql压力 -- redis 
使用了redis

### 数据库分布式事务解决方案
掌握不深 todo
### 1. 两阶段提交 -XA事务模型

首先事务协调者发送prepare请求给所有参与者
每个参与者在本地执行事务 写redo undo日志 但不提交
其次再发送commit请求 or rollback请求

存在问题是如果协调者在发送commit之前宕机 或者参与者在收到commit之前宕机

两阶段提交存在的问题 
1. 同步阻塞问题 不提交 锁住所有的服务器资源 
2. 单点故障问题 如果迟迟不发布提交或者回滚消息
3. 数据极端情况下一致性问题 如果在commit之前发生宕机 导致个别节点没有完成事务的操作

### 2.三阶段提交 
增加canCommit阶段
超时强制提交 

但是仍然存在发送者或参与者宕机的问题

### 3. TCC方案
